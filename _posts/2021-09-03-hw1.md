---
layout: post
title: "Homework 1"
date: 2021-09-03
excerpt: "Math is Fun"
tags: [post]
comments: true
---


###  HW1. Math is Fun
Solve 3 problems from the [Eular Project](https://projecteuler.net/archives) using Python. Of the 3 problems, one must have been solved by fewer than 25,000 people, 1 fewer than 100,000 people and one fewer than 500,000 people. 

###  Problem 10. Summation of primes (solved by 330,399)
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. 
Find the sum of all the primes below two million.

#### Approach
If a number is not divided by all prime numbers that are not greater than its square root, then it is a prime number. To calculate the sum of all prime numbers from 2 to 2,000,000, a prime number list can be created and used to judge the next number. If the next number is prime, then add it to the list. Since only singular numbers after 2 can be prime, the step size can be set to 2 during iteration. The sum of all numbers in the prime number list is final answer.

```
def summation_of_primes(limit):
    """
    Use the first three prime numbers to find all prime numbers from 2 to 200,000 
    and store them in a list, returning the sum of prime numbers in the list.
    
    Parameters
    ----------
    limit : int
            The limitation of all prime numbers.
    prime : list
            Store all prime numbers.
    x     : binary int
            0 or 1 converted from boolean.
    
    Returns
    -------
    int
        The summation of all prime numbers from 2 to 200,000.
        
    See Also
    --------
    math.sqrt: Square root of any number.
    """
    prime = [2,3,5]
    for num in range(7,limit,2):
        x = 1
        for p in prime:
            if(p > math.sqrt(num)+1):
                break
            if(num % p == 0):
                x = 0
                break
        if x == 1:
            prime.append(num)
    return np.sum(prime)
```
Output
```
>>> print(summation_of_primes(200000))
1709600813
```
Thus, the sum of all the primes below two million is 1709600813.

### Problem 45. Triangular, pentagonal, and hexagonal (solved by 71,490)
Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

|Shape|Formula|Number|
|----------|-----------------------|--------------------|
|Triangle  |T<sub>n</sub>=n(n+1)/2 |1, 3, 6, 10, 15, ...|
|Pentagonal|P<sub>n</sub>=n(3n−1)/2|1, 5, 12, 22, 35, ...|
|Hexagonal |H<sub>n</sub>=n(2n−1)  |1, 6, 15, 28, 45, ...|

It can be verified that T<sub>285</sub> = P<sub>165</sub> = H<sub>143</sub> = 40755.
Find the next triangle number that is also pentagonal and hexagonal.

#### Approach
First of all, it can be observed that a hexagonal number is a triangular number at an odd position. In fact, for any odd number (2n−1), after substituting it into the triangle number, we get (2n−1)(2n−1+1)/2=n(2n−1) which is a hexagonal number. Therefore, the hexagonal number is a subset of the triangular number. When a number is a hexagonal number, we no longer need to verify whether it is a triangular number. We sequentially generate hexagonal numbers from n=144, and then determine whether the generated number is a pentagonal number, if it is not, then generate the next number, if it is, then return the hexagonal number, which is the answer.

To determine whether a number is a pentagonal number, we find the inverse function of the general term of the pentagonal number, that is, n=((1+24x)<sup>1/2</sup>+1)/6. Only when ((1+24x)<sup>1/2</sup>+1) mod 6 = 0, the number is a pentagonal number.

```
def tri_penta_hexa(n):
    """
    Find the next hexagonal number and determine if it is also a pentagonal number.
    
    Parameters
    ----------
    n : int
        The starting hexagonal number.
    x : binary int
        0 or 1 converted from boolean.
    
    Returns
    -------
    int
        The next triangle number that is also pentagonal and hexagonal.
           
    See Also
    --------
    math.sqrt: Square root of any number.
    """
    x = 1
    while x==1:
        h = n*(2*n-1)
        if (math.sqrt(24*h+1)+1)%6==0:
            return h
        else:
            n += 1
```
Output
```
>>> print(tri_penta_hexa(144))
1533776805
```
Thus, the next triangle number that is also pentagonal and hexagonal is 1533776805.

### Problem 75. Singular integer right triangles (solved by 17,927)
It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle triangle in exactly one way, but there are many more examples.

12 cm: (3,4,5);  
24 cm: (6,8,10);  
30 cm: (5,12,13);  
36 cm: (9,12,15);  
40 cm: (8,15,17);  
48 cm: (12,16,20)

In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it is possible to form exactly three different integer sided right angle triangles.

120 cm: (30,40,50), (20,48,52), (24,45,51)

Given that L is the length of the wire, for how many values of L ≤ 1,500,000 can exactly one integer sided right angle triangle be formed?

#### Approach
According to Euclidean formula, assuming m>n>0, gcd(m,n)=1 and m,n are not all odd numbers, then m,n can form a primitive Pythagorean triple (a,b,c), where a,b,c are mutually prime. a is the long leg, b is the short leg, and c is the hypotenuse, then:

a = m<sup>2</sup>−n<sup>2</sup>, b = 2mn, c = m<sup>2</sup>+n<sup>2</sup>

Multiply (a,b,c) by k (k≥1) at the same time, then (ka, kb, kc) is also a Pythagorean triple. The perimeter of the Pythagorean tripe is:

p = ka+kb+kc = k(a+b+c) = 2km(m+n)

Therefore, as long as we get the perimeter of a set of primitive Pythagorean triple numbers, we can get the perimeters of other Pythagorean triple numbers.

According to the question, the maximum perimeter can only be 1.5 million:
2km(m+n) ≤ 1500000 ⇒ m ≤ (1500000/2k)<sup>1/2</sup> ≤ (1500000/2)<sup>1/2</sup>

With the equation above, we can get the m, n values in the range, calculate the perimeter, count the number of times each perimeter appears, and return the number of perimeters that only appear once, which is the answer.

```
def singular_integer_right_triangles(limit):
    """
    Find primitive Pythagorean triple, calculate the perimeter, count the number of times 
    each perimeter appears, and return the number of perimeters that only appear once.
    
    Parameters
    ----------
    limit : int
            The limitation of triangle perimeter.
    arr   : list
            Store the perimeters less or equal to the limitation.
    k     : int
            Multiply with primitive Pythagorean triple to get all Pythagorean triples.
    c     : int
            Count the number of occurrences of each perimeter.
    
    Returns
    -------
    int
        Sum of the number of triangle perimeters that only appear once.
    
    See Also
    --------
    math.sqrt: Square root of any number.
    math.gcd: Greatest common divisor of the two integers
    Counter: Container that keeps track of how many times equivalent values are added.
    """
    arr = []
    m_max = int(math.sqrt(limit/2))
    for m in range(2, m_max+1):
        for n in range(1, m):
            if (m + n) % 2 == 1 and math.gcd(m, n) == 1:
                p = 2*m*(m+n)
                k = 1
                while k*p <= limit:
                    arr.append(k*p)
                    k += 1
    c = Counter(arr)
    return len([x for x in c.values() if x==1])
```
Output
```
>>> print(singular_integer_right_triangles(1500000))
161667
```
Thus, given that L is the length of the wire, 161667 values of L ≤ 1,500,000 can exactly form one integer sided right angle triangle.

